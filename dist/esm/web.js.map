{"version":3,"file":"web.js","sourceRoot":"","sources":["../../src/web.ts"],"names":[],"mappings":"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","sourcesContent":["import { WebPlugin } from \"@capacitor/core\";\n\nimport type { UploaderPlugin, uploadOption } from \"./definitions\";\n\nexport class UploaderWeb extends WebPlugin implements UploaderPlugin {\n  private uploads: Map<\n    string,\n    { controller: AbortController; retries: number }\n  > = new Map();\n\n  async startUpload(options: uploadOption): Promise<{ id: string }> {\n    console.log(\"startUpload\", options);\n\n    const id = Math.random().toString(36).substring(2, 15);\n    const controller = new AbortController();\n    const maxRetries = options.maxRetries || 3;\n    this.uploads.set(id, { controller, retries: maxRetries });\n\n    this.doUpload(id, options);\n\n    return { id };\n  }\n\n  async removeUpload(options: { id: string }): Promise<void> {\n    console.log(\"removeUpload\", options);\n    const upload = this.uploads.get(options.id);\n    if (upload) {\n      upload.controller.abort();\n      this.uploads.delete(options.id);\n      this.notifyListeners(\"events\", {\n        name: \"cancelled\",\n        id: options.id,\n        payload: {},\n      });\n    }\n  }\n\n  private async doUpload(id: string, options: uploadOption) {\n    const {\n      filePath,\n      serverUrl,\n      headers = {},\n      method = \"POST\",\n      parameters = {},\n    } = options;\n    const upload = this.uploads.get(id);\n\n    if (!upload) return;\n\n    try {\n      const file = await this.getFileFromPath(filePath);\n      if (!file) throw new Error(\"File not found\");\n\n      const formData = new FormData();\n      formData.append(\"file\", file);\n\n      for (const [key, value] of Object.entries(parameters)) {\n        formData.append(key, value);\n      }\n\n      const response = await fetch(serverUrl, {\n        method,\n        headers,\n        body: method === \"PUT\" ? file : formData,\n        signal: upload.controller.signal,\n      });\n\n      if (!response.ok)\n        throw new Error(`HTTP error! status: ${response.status}`);\n\n      this.notifyListeners(\"events\", {\n        name: \"completed\",\n        id,\n        payload: { statusCode: response.status },\n      });\n\n      this.uploads.delete(id);\n    } catch (error) {\n      if ((error as Error).name === \"AbortError\") return;\n\n      if (upload.retries > 0) {\n        upload.retries--;\n        console.log(`Retrying upload (retries left: ${upload.retries})`);\n        setTimeout(() => this.doUpload(id, options), 1000);\n      } else {\n        this.notifyListeners(\"events\", {\n          name: \"failed\",\n          id,\n          payload: { error: (error as Error).message },\n        });\n        this.uploads.delete(id);\n      }\n    }\n  }\n\n  private async getFileFromPath(filePath: string): Promise<File | null> {\n    // This is a simplified version. In a real-world scenario,\n    // you might need to handle different types of paths or use a file system API.\n    try {\n      const response = await fetch(filePath);\n      const blob = await response.blob();\n      return new File([blob], filePath.split(\"/\").pop() || \"file\", {\n        type: blob.type,\n      });\n    } catch (error) {\n      console.error(\"Error getting file:\", error);\n      return null;\n    }\n  }\n}\n"]}